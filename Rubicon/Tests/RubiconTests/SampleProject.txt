"\n\n//\n//  ArgumentsController.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 01/05/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\npublic class ArgumentsController {\n\n    private let fileReader: FileReader\n    private let helpController: HelpController\n    private let mocksController: MocksGeneratorController\n\n    public init(fileReader: FileReader, helpController: HelpController, mocksController: MocksGeneratorController) {\n        self.fileReader = fileReader\n        self.helpController = helpController\n        self.mocksController = mocksController\n    }\n\n    public func run(arguments: [String]) {\n        guard arguments.indices.contains(2) else {\n            helpController.run()\n            return\n        }\n\n        let result = fileReader.readFiles(at: arguments[2])\n        mocksController.run(text: result)\n    }\n\n}\n\n\n//\n//  ArgumentsParser.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 01/05/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\npublic enum Arguments {\n    case help\n    case mocks(path: String)\n}\n\npublic class ArgumentsParser {\n\n    public init() {}\n\n    public func parse(arguments: [String]) -> Arguments {\n        if arguments.indices.contains(1), arguments[0] == \"--mocks\" {\n            return .mocks(path: arguments[1])\n        }\n\n        return .help\n    }\n\n}\n\n\n//\n//  CommandLineAssembly.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 06/05/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nclass CommandLineAssembly {\n\n    func makeArguments(arguments: [String]) {\n        let fileReader = FileReaderImpl()\n        let output = StandardGeneratorOutput()\n        let helpController = HelpControllerImpl(output: output)\n        let mocksController = MocksGeneratorControllerImpl(output: output)\n\n        let argumentsController = ArgumentsController(fileReader: fileReader, helpController: helpController, mocksController: mocksController)\n        argumentsController.run(arguments: arguments)\n    }\n\n}\n\n\n//\n//  MockGeneratorController.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 05/05/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\npublic protocol MocksGeneratorController {\n    func run(text: String)\n}\n\npublic class MocksGeneratorControllerImpl {\n\n    fileprivate let output: GeneratorOutput\n\n    public init(output: GeneratorOutput) {\n        self.output = output\n    }\n\n}\n\nextension MocksGeneratorControllerImpl: MocksGeneratorController {\n\n    public func run(text: String) {\n        let parser = Parser()\n        let tokens = parser.parse(text)\n\n        guard let storage = try? Storage(tokens: tokens) else {\n            output.save(text: \"\")\n            return\n        }\n\n        var isTextSearched = true\n\n        while isTextSearched {\n            do {\n                try storage.moveToNext(.protocol)\n                processProtocol(storage: storage)\n            } catch {\n                isTextSearched = false\n                return\n            }\n        }\n    }\n\n    private func processProtocol(storage: Storage) {\n        let protocolParser = ProtocolParser()\n\n        do {\n            let protocolType = try protocolParser.parse(storage: storage)\n            let generator = ProtocolSpyGeneratorController()\n            let text = generator.generate(from: protocolType)\n            output.save(text: text)\n        } catch {\n            output.save(text: \"\")\n        }\n    }\n\n}\n\n\n//\n//  ProtocolSpyGeneratorController.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 05/05/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\npublic class ProtocolSpyGeneratorController {\n\n    func generate(from protocolType: ProtocolType) -> String {\n        var result = \"\"\n        result += \"class \\(protocolType.name)Spy: \\(protocolType.name) {\\n\"\n        result += generateBody(from: protocolType)\n        result += \"}\\n\\n\"\n        return result\n    }\n\n    private func generateBody(from protocolType: ProtocolType) -> String {\n        var content = [String]()\n\n        if !protocolType.variables.isEmpty {\n            content.append(generateVariables(protocolType.variables))\n        }\n\n        for function in protocolType.functions {\n            content.append(generateFunctionVariables(function))\n        }\n\n        for function in protocolType.functions {\n            content.append(generateFunctionDefinitions(function))\n        }\n\n        if !content.isEmpty {\n            return \"\\n\\(content.joined(separator: \"\\n\"))\\n\"\n        } else {\n            return \"\"\n        }\n    }\n\n    private func generateVariables(_ variables: [VarDeclarationType]) -> String {\n        var result = \"\"\n\n        for variable in variables {\n            result += \"var \\(variable.identifier): \\(variable.type.name)!\\n\"\n        }\n\n        return result\n    }\n\n    private func generateFunctionVariables(_ function: FunctionDeclarationType) -> String {\n        var result = \"\"\n        result += \"var \\(function.name)Count = 0\\n\"\n\n        for argument in function.arguments {\n            result += \"var \\(function.name)\\(argument.name.capitalized): \\(argument.type.name)?\\n\"\n        }\n\n        return result\n    }\n\n    private func generateArgument(_ argument: ArgumentType) -> String {\n        let labelString: String\n\n        if let label = argument.label {\n            labelString = \"\\(label) \"\n        } else {\n            labelString = \"\"\n        }\n\n        let optionalLabel = argument.type.isOptional ? \"?\" : \"\"\n        return \"\\(labelString)\\(argument.name): \\(argument.type.name)\\(optionalLabel)\"\n    }\n\n    private func generateFunctionDefinitions(_ function: FunctionDeclarationType) -> String {\n        var result = \"\"\n        let argumentsString = function.arguments.map(generateArgument).joined(separator: \", \")\n        result += \"func \\(function.name)(\\(argumentsString)) {\\n\"\n        result += \"\\(function.name)Count += 1\\n\"\n\n        for argument in function.arguments {\n            result += \"\\(function.name)\\(argument.name.capitalized) = \\(argument.name)\\n\"\n        }\n\n        result += \"}\\n\"\n        return result\n    }\n\n}\n\n\n//\n//  HelpController.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 06/05/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\npublic protocol HelpController {\n    func run()\n}\n\npublic class HelpControllerImpl {\n\n    fileprivate let output: ErrorGeneratorOutput\n\n    public init(output: ErrorGeneratorOutput) {\n        self.output = output\n    }\n\n}\n\nextension HelpControllerImpl: HelpController {\n\n    public func run() {\n        var helpString = \"\"\n        helpString += \"Required arguments:\\n\"\n        helpString += \"--mocks path\\n\"\n        output.showError(text: helpString)\n    }\n\n}\n\n\n//\n//  Parser.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 20/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\npublic class Parser {\n\n    private var buffer: String = \"\"\n    private var results = [Token]()\n\n    public init() {\n    }\n\n    public func parse(_ text: String) -> [Token] {\n        let text = text + \" \"\n        var index = text.startIndex\n        let range = text.startIndex ..< text.endIndex\n\n        while range.contains(index) {\n            switch text[index] {\n            case \":\":\n                addToResult(.colon)\n            case \"{\":\n                addToResult(.leftCurlyBracket)\n            case \"}\":\n                addToResult(.rightCurlyBracket)\n            case \"(\":\n                addToResult(.leftBracket)\n            case \")\":\n                addToResult(.rightBracket)\n            case \"=\":\n                addToResult(.equal)\n            case \"?\":\n                addToResult(.questionMark)\n            case \",\":\n                addToResult(.comma)\n            case \"-\":\n                index = parseArrow(from: index, in: text)\n            case \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"`\":\n                index = parseName(from: index, in: text)\n            default:\n                break\n            }\n\n            index = text.index(after: index)\n        }\n\n        return results\n    }\n\n    private func parseName(from index: String.Index, in text: String) -> String.Index {\n        let identifierCharacters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_\".characters\n        var index = index\n        buffer = \"\"\n        var isEndBackwardsQuoteRequired = false\n\n        if text[index] == \"`\" {\n            index = text.index(after: index)\n            isEndBackwardsQuoteRequired = true\n        }\n\n        let indices = text.characters.indices\n\n        while indices.contains(index) {\n            let character = text[index]\n\n            if identifierCharacters.contains(character) {\n                buffer += String(character)\n            } else {\n                if text[index] == \"`\" && isEndBackwardsQuoteRequired {\n                    index = text.index(after: index)\n                    addToResult(.identifier(name: buffer))\n                } else {\n                    determineNameType(name: buffer)\n                }\n\n                return text.index(before: index)\n            }\n\n            index = text.index(after: index)\n        }\n\n        return index\n    }\n\n    private func parseArrow(from index: String.Index, in text: String) -> String.Index {\n        let secondIndex = text.index(after: index)\n\n        if text.characters.indices.contains(index) && text.characters.indices.contains(secondIndex) {\n            let character = text[index]\n            let character2 = text[secondIndex]\n\n            if character == \"-\" && character2 == \">\" {\n                addToResult(.arrow)\n                return secondIndex\n            }\n        }\n\n        return secondIndex\n    }\n\n    private func determineNameType(name: String) {\n        let token: Token\n\n        switch name {\n        case \"protocol\":\n            token = .protocol\n        case \"var\":\n            token = .variable\n        case \"let\":\n            token = .constant\n        case \"get\":\n            token = .get\n        case \"set\":\n            token = .set\n        case \"func\":\n            token = .function\n        default:\n            token = .identifier(name: name)\n        }\n\n        addToResult(token)\n    }\n\n    private func addToResult(_ token: Token) {\n        results.append(token)\n    }\n}\n\n\n//\n//  Storage.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 26/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nenum StorageError: Error {\n    case noTokens\n    case noNextToken\n    case noPreviousToken\n    case indexOutOfBounds\n}\n\npublic class Storage {\n\n    public var current: Token {\n        return tokens[index]\n    }\n\n    private let tokens: [Token]\n    private var index = 0\n\n    init(tokens: [Token]) throws {\n        guard !tokens.isEmpty else {\n            throw StorageError.noTokens\n        }\n\n        self.tokens = tokens\n    }\n\n    public func next() throws -> Token {\n        let newIndex = index + 1\n\n        guard tokens.indices.contains(newIndex) else {\n            throw StorageError.noNextToken\n        }\n\n        index = newIndex\n        return current\n    }\n\n    public func previous() throws -> Token {\n        let newIndex = index - 1\n\n        guard tokens.indices.contains(newIndex) else {\n            throw StorageError.noPreviousToken\n        }\n\n        index = newIndex\n        return current\n    }\n\n    public func currentIndex() -> Int {\n        return index\n    }\n\n    public func setCurrentIndex(_ index: Int) throws {\n        guard tokens.indices.contains(index) else {\n            throw StorageError.indexOutOfBounds\n        }\n\n        self.index = index\n    }\n\n    public func moveToNext(_ token: Token) throws {\n        let restOfTokens = tokens[index ..< tokens.count]\n        \n        if let newIndex = restOfTokens.index(of: token) {\n            index = newIndex\n        } else {\n            throw StorageError.noNextToken\n        }\n    }\n\n}\n\n\n//\n//  Token.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 20/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\npublic enum Token {\n    case identifier(name: String)\n    case `protocol`\n    case leftCurlyBracket\n    case rightCurlyBracket\n    case leftBracket\n    case rightBracket\n    case colon\n    case comma\n    case questionMark\n    case equal\n    case variable\n    case constant\n    case get\n    case set\n    case function\n    case arrow\n}\n\nextension Token: Equatable {\n    public static func ==(lhs: Token, rhs: Token) -> Bool {\n\n        switch (lhs, rhs) {\n        case let (.identifier(name1), .identifier(name2)) :\n            return name1 == name2\n        case (.protocol, .protocol):\n            return true\n        case (.leftCurlyBracket, .leftCurlyBracket):\n            return true\n        case (.rightCurlyBracket, .rightCurlyBracket):\n            return true\n        case (.leftBracket, .leftBracket):\n            return true\n        case (.rightBracket, .rightBracket):\n            return true\n        case (.colon, .colon):\n            return true\n        case (.comma, .comma):\n            return true\n        case (.questionMark, .questionMark):\n            return true\n        case (.equal, .equal):\n            return true\n        case (.variable, .variable):\n            return true\n        case (.constant, .constant):\n            return true\n        case (.get, .get):\n            return true\n        case (.set, .set):\n            return true\n        case (.function, .function):\n            return true\n        case (.arrow, .arrow):\n            return true\n        default:\n            return false\n        }\n    }\n}\n\n\n//\n//  main.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 20/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nimport Foundation\n\nlet assembly = CommandLineAssembly()\nlet arguments = CommandLine.arguments\nassembly.makeArguments(arguments: arguments)\n\n\n//\n//  FileReaderImpl.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 06/05/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nimport Foundation\n\npublic protocol FileReader {\n    func readFiles(at path: String) -> String\n}\n\nclass FileReaderImpl: FileReader {\n\n    func readFiles(at path: String) -> String {\n        let fileNames = findFileNames(at: path)\n        let contentOfFiles = fileNames.flatMap({ return try? String(contentsOfFile: $0, encoding: .utf8) })\n        return contentOfFiles.reduce(\"\", { $0 + \"\\n\\n\" + $1})\n    }\n\n    private func findFileNames(at path: String) -> [String] {\n        let fileManager = FileManager.default\n\n        var fileNames = [String]()\n\n        let items = try FileManager.default.contentsOfDirectory(atPath: path)\n\n        for fileName in items {\n            let itemPath = path + \"/\" + fileName\n\n            var isDir : ObjCBool = false\n            if fileManager.fileExists(atPath: itemPath, isDirectory:&isDir) {\n                if isDir.boolValue {\n                    fileNames += findFileNames(at: itemPath)\n                } else {\n                    if fileName.hasSuffix(\".swift\") {\n                        fileNames.append(itemPath)\n                    }\n                }\n            }\n        }\n\n        return fileNames\n    }\n\n}\n\n\n//\n//  StandardGeneratorOutput.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 06/05/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nimport Foundation\n\npublic protocol GeneratorOutput {\n\n    func save(text: String)\n    \n}\n\npublic protocol ErrorGeneratorOutput {\n\n    func showError(text: String)\n\n}\n\nclass StandardGeneratorOutput {}\n\nextension StandardGeneratorOutput: GeneratorOutput {\n\n    func save(text: String) {\n        print(text)\n    }\n\n}\n\nextension StandardGeneratorOutput: ErrorGeneratorOutput {\n\n    func showError(text: String) {\n        var errorStream = StderrOutputStream()\n        print(text, to: &errorStream)\n        exit(1)\n    }\n\n}\n\nprivate struct StderrOutputStream: TextOutputStream {\n    public mutating func write(_ string: String) {\n        fputs(string, stderr)\n    }\n}\n\n\n//\n//  ArgumentParser.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 27/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nenum ArgumentParserError: Error {\n    case invalidName\n    case invalidColon\n    case invalidType\n}\n\npublic class ArgumentParser {\n\n    private let typeParser = TypeParser()\n\n    func parse(storage: Storage) throws -> ArgumentType {\n        guard case .identifier(let label) = storage.current else {\n            throw ArgumentParserError.invalidName\n        }\n\n        guard let secondToken = try? storage.next() else {\n            throw ArgumentParserError.invalidColon\n        }\n\n        if case .identifier(let name) = secondToken {\n            _ = try? storage.next()\n            return try parseColon(in: storage, label: label, name: name)\n        } else {\n            return try parseColon(in: storage, label: nil, name: label)\n        }\n    }\n\n    private func parseColon(in storage: Storage, label: String?, name: String) throws -> ArgumentType {\n        guard storage.current == .colon else {\n            throw ArgumentParserError.invalidColon\n        }\n\n        _ = try? storage.next()\n\n        guard let type = try? typeParser.parse(storage: storage) else {\n            throw ArgumentParserError.invalidType\n        }\n\n        return ArgumentType(label: label, name: name, type: type)\n    }\n\n}\n\n\n//\n//  FunctionDeclarationParser.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 26/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\npublic enum FunctionDeclarationParserError: Error {\n    case invalidFunctionToken\n    case invalidNameToken\n    case invalidLeftBracketToken\n    case invalidFunctionArgument\n}\n\npublic class FunctionDeclarationParser {\n\n    private var argumentParser = ArgumentParser()\n\n    public func parse(storage: Storage) throws -> FunctionDeclarationType {\n        let index = storage.currentIndex()\n        guard storage.current == .function else {\n            throw FunctionDeclarationParserError.invalidFunctionToken\n        }\n\n        guard let nextToken = try? storage.next(), case let .identifier(name) = nextToken else {\n            try? storage.setCurrentIndex(index)\n            throw FunctionDeclarationParserError.invalidNameToken\n        }\n\n        guard let leftBracketToken = try? storage.next(), leftBracketToken == .leftBracket else {\n            try? storage.setCurrentIndex(index)\n            throw FunctionDeclarationParserError.invalidLeftBracketToken\n        }\n\n        _ = try? storage.next()\n        var arguments = [ArgumentType]()\n\n        if let argument = try? argumentParser.parse(storage: storage) {\n            arguments.append(argument)\n        }\n\n        while storage.current == .comma {\n            _ = try? storage.next()\n\n            if let argument = try? argumentParser.parse(storage: storage) {\n                arguments.append(argument)\n            }\n        }\n\n        guard storage.current == .rightBracket else {\n            try? storage.setCurrentIndex(index)\n            throw FunctionDeclarationParserError.invalidFunctionArgument\n        }\n\n        _ = try? storage.next()\n        return FunctionDeclarationType(name: name, arguments: arguments)\n    }\n}\n\n\n//\n//  ProtocolParser.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 26/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nenum ProtocolParserError: Error {\n    case invalidProtocolToken\n    case invalidNameToken\n    case expectedLeftBracket\n    case expectedRightBracket\n}\n\npublic class ProtocolParser {\n\n    private let variableParser = VarDeclarationTypeParser()\n    private let functionParser = FunctionDeclarationParser()\n\n    public func parse(storage: Storage) throws -> ProtocolType {\n        guard storage.current == .protocol else {\n            throw ProtocolParserError.invalidProtocolToken\n        }\n\n        guard let nameToken = try? storage.next(), case let .identifier(name) = nameToken else {\n            throw ProtocolParserError.invalidNameToken\n        }\n\n        guard let leftBracketToken = try? storage.next(), leftBracketToken == .leftCurlyBracket else {\n            throw ProtocolParserError.expectedLeftBracket\n        }\n\n        _ = try? storage.next()\n        let protocolType = parseProtocol(with: name, storage: storage)\n\n        guard storage.current == .rightCurlyBracket else {\n            throw ProtocolParserError.expectedRightBracket\n        }\n\n        _ = try? storage.next()\n        return protocolType\n    }\n\n    private func parseProtocol(with name: String, storage: Storage) -> ProtocolType {\n        var variables = [VarDeclarationType]()\n        var functions = [FunctionDeclarationType]()\n\n        var isSomethingParsed = true\n\n        while isSomethingParsed {\n            isSomethingParsed = false\n\n            if let variable = try? variableParser.parse(storage: storage) {\n                variables.append(variable)\n                isSomethingParsed = true\n            }\n\n            if let function = try? functionParser.parse(storage: storage) {\n                functions.append(function)\n                isSomethingParsed = true\n            }\n        }\n\n        return ProtocolType(name: name, variables: variables, functions: functions)\n    }\n}\n\n\n//\n//  TypeParser.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 23/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nenum TypeParserError: Error {\n    case invalidName\n}\n\npublic class TypeParser {\n\n    public func parse(storage: Storage) throws -> Type {\n        guard case let .identifier(name) = storage.current else {\n            throw TypeParserError.invalidName\n        }\n\n        if let token = try? storage.next() {\n            if token == .questionMark {\n                _ = try? storage.next()\n                return Type(name: name, isOptional: true)\n            }\n        }\n\n        return Type(name: name, isOptional: false)\n    }\n}\n\n\n//\n//  VarDeclarationTypeParser.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 23/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\npublic enum VarDeclarationTypeError: Error {\n    case invalidTokens\n}\n\npublic class VarDeclarationTypeParser {\n\n    private enum State {\n        case start\n        case variable\n        case name\n        case colon\n        case type\n        case leftCurlyBracket\n        case get\n        case set\n        case setFirst\n        case rightCurlyBracket\n        case error\n    }\n\n    public func parse(storage: Storage) throws -> VarDeclarationType {\n        var isConstant = true\n        var isEnd = false\n        var state = State.start\n        var identifier: String?\n        var type: Type?\n        let index = storage.currentIndex()\n\n        while !isEnd {\n            let token: Token?\n\n            if state != .start, state != .type {\n                token = try? storage.next()\n            } else {\n                token = storage.current\n            }\n\n            switch state {\n            case .start:\n                if token == .variable {\n                    state = .variable\n                } else {\n                    state = .error\n                }\n            case .variable:\n                if let token = token, case let .identifier(name) = token {\n                    identifier = name\n                    state = .name\n                } else {\n                    state = .error\n                }\n            case .name:\n                if token == .colon {\n                    state = .colon\n                } else {\n                    state = .error\n                }\n            case .colon:\n                let varType = try? TypeParser().parse(storage: storage)\n                if let varType = varType {\n                    type = varType\n                    state = .type\n                } else {\n                    state = .error\n                }\n            case .type:\n                if token == .leftCurlyBracket {\n                    state = .leftCurlyBracket\n                } else {\n                    state = .error\n                }\n            case .leftCurlyBracket:\n                if token == .get {\n                    state = .get\n                } else if token == .set {\n                    state = .setFirst\n                } else {\n                    state = .error\n                }\n            case .get:\n                if token == .set {\n                    state = .set\n                } else if token == .rightCurlyBracket {\n                    state = .rightCurlyBracket\n                } else {\n                    state = .error\n                }\n            case .set:\n                isConstant = false\n\n                if token == .rightCurlyBracket {\n                    state = .rightCurlyBracket\n                } else {\n                    state = .error\n                }\n            case .setFirst:\n                isConstant = false\n\n                if token == .get {\n                    state = .get\n                } else {\n                    state = .error\n                }\n            case .rightCurlyBracket:\n                if let identifier = identifier, let type = type {\n                    return VarDeclarationType(isConstant: isConstant, identifier: identifier, type: type)\n                }\n            case .error:\n                isEnd = true\n            }\n        }\n\n        try? storage.setCurrentIndex(index)\n        throw VarDeclarationTypeError.invalidTokens\n    }\n}\n\n\n//\n//  ArgumentType.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 27/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\npublic struct ArgumentType {\n    public var label: String?\n    public var name: String\n    public var type: Type\n}\n\n\n//\n//  FunctionDeclarationType.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 26/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\npublic struct FunctionDeclarationType {\n    public var name: String\n    public var arguments: [ArgumentType]\n}\n\n\n//\n//  ProtocolType.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 26/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\npublic struct ProtocolType {\n    public var name: String\n    public var variables: [VarDeclarationType]\n    public var functions: [FunctionDeclarationType]\n}\n\n\n//\n//  Type.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 26/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\npublic struct Type {\n    public var name: String\n    public var isOptional: Bool\n}\n\n\n//\n//  VarDeclarationType.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 22/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\npublic struct VarDeclarationType {\n    public var isConstant: Bool\n    public var identifier: String\n    public var type: Type\n}\n\n\n//\n//  ArgumentsControllerTests.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 01/05/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nimport XCTest\n\nclass ArgumentsControllerTests: XCTestCase {\n\n    func test_givenInvalidArguments_whenRun_thenShowHelp() {\n        let fileReaderSpy = FileReaderSpy()\n        let helpControllerSpy = HelpControllerSpy()\n        let argumentsController = ArgumentsController(fileReader: fileReaderSpy, helpController: helpControllerSpy, mocksController: MocksGeneratorControllerSpy())\n        argumentsController.run(arguments: [\"sd\"])\n        XCTAssertEqual(helpControllerSpy.runCount, 1)\n    }\n\n    func test_givenMocksArguments_whenRun_thenReadFile() {\n        let fileReaderSpy = FileReaderSpy()\n        let helpControllerSpy = HelpControllerSpy()\n        let mocksControllerSpy = MocksGeneratorControllerSpy()\n        let argumentsController = ArgumentsController(fileReader: fileReaderSpy, helpController: helpControllerSpy, mocksController: mocksControllerSpy)\n        argumentsController.run(arguments: [\"rubicon\", \"--mocks\", \"*\"])\n        XCTAssertEqual(fileReaderSpy.readFilesCount, 1)\n        XCTAssertEqual(fileReaderSpy.path, \"*\")\n        XCTAssertEqual(helpControllerSpy.runCount, 0)\n    }\n\n    func test_givenMocksArguments_whenRun_thenParseToStorage() {\n        let fileReaderSpy = FileReaderSpy()\n        fileReaderSpy.result = \"protocol string\"\n        let mocksControllerSpy = MocksGeneratorControllerSpy()\n        let argumentsController = ArgumentsController(fileReader: fileReaderSpy, helpController: HelpControllerSpy(), mocksController: mocksControllerSpy)\n        argumentsController.run(arguments: [\"rubicon\", \"--mocks\", \"*\"])\n        XCTAssertEqual(mocksControllerSpy.runCount, 1)\n        XCTAssertEqual(mocksControllerSpy.text, \"protocol string\")\n    }\n\n}\n\nprivate class FileReaderSpy: FileReader {\n\n    var readFilesCount = 0\n    var path = \"\"\n    var result = \"\"\n\n    func readFiles(at path: String) -> String {\n        readFilesCount += 1\n        self.path = path\n        return result\n    }\n\n}\n\nprivate class HelpControllerSpy: HelpController {\n\n    var runCount = 0\n\n    func run() {\n        runCount += 1\n    }\n\n}\n\nprivate class MocksGeneratorControllerSpy: MocksGeneratorController {\n\n    var runCount = 0\n    var text = \"\"\n\n    func run(text: String) {\n        runCount += 1\n        self.text = text\n    }\n\n}\n\n\n//\n//  ArgumentsParserTests.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 01/05/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nimport XCTest\n\nclass ArgumentsParserTests: XCTestCase {\n\n    private let argumentsParser = ArgumentsParser()\n\n    func test_givenEmptyParameters_whenParse_thenParseHelp() {\n        let arguments = argumentsParser.parse(arguments: [])\n\n        guard case .help = arguments else {\n            XCTFail()\n            return\n        }\n    }\n\n    func test_givenMocksWithoutPath_whenParse_thenParseHelp() {\n        let arguments = argumentsParser.parse(arguments: [\"--mocks\"])\n\n        guard case .help = arguments else {\n            XCTFail()\n            return\n        }\n    }\n\n    func test_givenMocksWithPath_whenParse_thenParseMocks() {\n        let arguments = argumentsParser.parse(arguments: [\"--mocks\", \".\"])\n\n        guard case .mocks(let path) = arguments else {\n            XCTFail()\n            return\n        }\n\n        XCTAssertEqual(path, \".\")\n    }\n\n}\n\n\n//\n//  XCTextCase.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 26/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nimport XCTest\n\nextension XCTestCase {\n\n    func testException<E: Error>(with exception: E, parse: (() throws -> Void)) where E: Equatable {\n        do {\n            try parse()\n        } catch let (error as E) {\n            XCTAssertEqual(error, exception)\n            return\n        } catch {}\n\n        XCTFail()\n    }\n}\n\n\n//\n//  MockGeneratorControllerTests.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 05/05/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nimport XCTest\n\nclass MockGeneratorControllerTests: XCTestCase {\n\n    func test_givenEmptyString_whenRun_thenGenerateEmptyString() {\n        let generatorOutput = GeneratorOutputSpy()\n        let generator = MocksGeneratorControllerImpl(output: generatorOutput)\n        generator.run(text: \"\")\n        XCTAssertEqual(generatorOutput.text, \"\")\n        XCTAssertEqual(generatorOutput.saveCount, 1)\n    }\n\n    func test_givenNoProtocol_whenRun_thenGenerateEmptyString() {\n        let generatorOutput = GeneratorOutputSpy()\n        let generator = MocksGeneratorControllerImpl(output: generatorOutput)\n        generator.run(text: \"class X {\")\n        XCTAssertEqual(generatorOutput.text, \"\")\n        XCTAssertEqual(generatorOutput.saveCount, 0)\n    }\n\n    func test_givenIncompleteProtocol_whenRun_thenGenerateEmptyString() {\n        let generatorOutput = GeneratorOutputSpy()\n        let generator = MocksGeneratorControllerImpl(output: generatorOutput)\n        generator.run(text: \"protocol X {\")\n        XCTAssertEqual(generatorOutput.text, \"\")\n        XCTAssertEqual(generatorOutput.saveCount, 1)\n    }\n\n    func test_givenEmptyProtocol_whenRun_thenGenerateEmptySpy() {\n        let generatorOutput = GeneratorOutputSpy()\n        let generator = MocksGeneratorControllerImpl(output: generatorOutput)\n        generator.run(text: \"protocol X {}\")\n        XCTAssertEqual(generatorOutput.text, \"class XSpy: X {\\n}\\n\\n\")\n        XCTAssertEqual(generatorOutput.saveCount, 1)\n    }\n\n    func test_givenEmptyProtocolInContext_whenRun_thenGenerateEmptySpy() {\n        let generatorOutput = GeneratorOutputSpy()\n        let generator = MocksGeneratorControllerImpl(output: generatorOutput)\n        generator.run(text: \"class {} protocol X {}\")\n        XCTAssertEqual(generatorOutput.text, \"class XSpy: X {\\n}\\n\\n\")\n        XCTAssertEqual(generatorOutput.saveCount, 1)\n    }\n\n    func test_givenTwoEmptyProtocolsInContext_whenRun_thenGenerateEmptySpy() {\n        let generatorOutput = GeneratorOutputSpy()\n        let generator = MocksGeneratorControllerImpl(output: generatorOutput)\n        generator.run(text: \"class {} protocol X {} var X protocol Y {}\")\n        XCTAssertEqual(generatorOutput.text, \"class XSpy: X {\\n}\\n\\nclass YSpy: Y {\\n}\\n\\n\")\n        XCTAssertEqual(generatorOutput.saveCount, 2)\n    }\n\n}\n\nprivate class GeneratorOutputSpy: GeneratorOutput {\n\n    var text = \"\"\n    var saveCount = 0\n\n    func save(text: String) {\n        self.text += text\n        saveCount += 1\n    }\n\n}\n\n\n//\n//  ProtocolSpyGeneratorControllerTests.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 05/05/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nimport XCTest\n\nclass ProtocolSpyGeneratorControllerTests: XCTestCase {\n\n    private let generator = ProtocolSpyGeneratorController()\n    private let type = Type(name: \"Color\", isOptional: false)\n\n    func test_givenprotocolType_whenGenerate_thenGenerateEmptySpy() {\n        let protocolType = ProtocolType(name: \"Test\", variables: [], functions: [])\n\n        equal(protocolType: protocolType, rows: [\n            \"class TestSpy: Test {\",\n            \"}\",\n            \"\",\n            \"\"\n            ]\n        )\n    }\n\n    func test_givenprotocolTypeWithLongName_whenGenerate_thenGenerateEmptySpy() {\n        let protocolType = ProtocolType(name: \"TestTestTestTestTest\", variables: [], functions: [])\n\n        equal(protocolType: protocolType, rows: [\n            \"class TestTestTestTestTestSpy: TestTestTestTestTest {\",\n            \"}\",\n            \"\",\n            \"\"\n            ]\n        )\n    }\n\n    func test_givenProtocolWithVariable_whenGenerate_thenGenerateSpy() {\n        let variable = VarDeclarationType(isConstant: false, identifier: \"color\", type: type)\n        let protocolType = ProtocolType(name: \"Car\", variables: [variable], functions: [])\n\n        equal(protocolType: protocolType, rows: [\n            \"class CarSpy: Car {\",\n            \"\",\n            \"var color: Color!\",\n            \"\",\n            \"}\",\n            \"\",\n            \"\"\n            ]\n        )\n    }\n\n    func test_givenProtocolWithConstant_whenGenerate_thenGenerateSpy() {\n        let type = Type(name: \"Color\", isOptional: true)\n        let variable = VarDeclarationType(isConstant: true, identifier: \"color\", type: type)\n        let protocolType = ProtocolType(name: \"Car\", variables: [variable], functions: [])\n        equal(protocolType: protocolType, rows: [\n            \"class CarSpy: Car {\",\n            \"\",\n            \"var color: Color!\",\n            \"\",\n            \"}\",\n            \"\",\n            \"\"\n            ]\n        )\n    }\n\n    func test_givenProtocolWithTwoVariables_whenGenerate_thenGenerateSpy() {\n        let variable = VarDeclarationType(isConstant: false, identifier: \"color\", type: type)\n        let protocolType = ProtocolType(name: \"Car\", variables: [variable, variable], functions: [])\n\n        equal(protocolType: protocolType, rows: [\n            \"class CarSpy: Car {\",\n            \"\",\n            \"var color: Color!\",\n            \"var color: Color!\",\n            \"\",\n            \"}\",\n            \"\",\n            \"\"\n            ]\n        )\n    }\n\n    func test_givenProtocolWithSimpleFunction_whenGenerate_thenGenerateSpy() {\n        let function = FunctionDeclarationType(name: \"start\", arguments: [])\n        let protocolType = ProtocolType(name: \"Car\", variables: [], functions: [function])\n\n        equal(protocolType: protocolType, rows: [\n            \"class CarSpy: Car {\",\n            \"\",\n            \"var startCount = 0\",\n            \"\",\n            \"func start() {\",\n            \"startCount += 1\",\n            \"}\",\n            \"\",\n            \"}\",\n            \"\",\n            \"\"\n            ]\n        )\n    }\n\n    func test_givenProtocolWithFunctionWithArgument_whenGenerate_thenGenerateSpy() {\n        let argument = ArgumentType(label: \"a\", name: \"b\", type: type)\n        let function = FunctionDeclarationType(name: \"start\", arguments: [argument])\n        let protocolType = ProtocolType(name: \"Car\", variables: [], functions: [function])\n\n        equal(protocolType: protocolType, rows: [\n            \"class CarSpy: Car {\",\n            \"\",\n            \"var startCount = 0\",\n            \"var startB: Color?\",\n            \"\",\n            \"func start(a b: Color) {\",\n            \"startCount += 1\",\n            \"startB = b\",\n            \"}\",\n            \"\",\n            \"}\",\n            \"\",\n            \"\"\n            ]\n        )\n    }\n\n    func test_givenProtocolWithFunctionWithTwoArguments_whenGenerate_thenGenerateSpy() {\n        let argument = ArgumentType(label: \"a\", name: \"b\", type: type)\n        let type2 = Type(name: \"Color\", isOptional: true)\n        let argument2 = ArgumentType(label: nil, name: \"d\", type: type2)\n        let function = FunctionDeclarationType(name: \"start\", arguments: [argument, argument2])\n        let protocolType = ProtocolType(name: \"Car\", variables: [], functions: [function])\n\n        equal(protocolType: protocolType, rows: [\n            \"class CarSpy: Car {\",\n            \"\",\n            \"var startCount = 0\",\n            \"var startB: Color?\",\n            \"var startD: Color?\",\n            \"\",\n            \"func start(a b: Color, d: Color?) {\",\n            \"startCount += 1\",\n            \"startB = b\",\n            \"startD = d\",\n            \"}\",\n            \"\",\n            \"}\",\n            \"\",\n            \"\"\n            ]\n        )\n    }\n\n    func test_givenProtocolWithTwoFunctionWithArgument_whenGenerate_thenGenerateSpy() {\n        let argument = ArgumentType(label: \"a\", name: \"b\", type: type)\n        let function = FunctionDeclarationType(name: \"start\", arguments: [argument])\n        let function2 = FunctionDeclarationType(name: \"stop\", arguments: [argument])\n        let protocolType = ProtocolType(name: \"Car\", variables: [], functions: [function, function2])\n\n        equal(protocolType: protocolType, rows: [\n            \"class CarSpy: Car {\",\n            \"\",\n            \"var startCount = 0\",\n            \"var startB: Color?\",\n            \"\",\n            \"var stopCount = 0\",\n            \"var stopB: Color?\",\n            \"\",\n            \"func start(a b: Color) {\",\n            \"startCount += 1\",\n            \"startB = b\",\n            \"}\",\n            \"\",\n            \"func stop(a b: Color) {\",\n            \"stopCount += 1\",\n            \"stopB = b\",\n            \"}\",\n            \"\",\n            \"}\",\n            \"\",\n            \"\"\n            ]\n        )\n    }\n\n    func test_givenProtocolWithFunctionAndVarible_whenGenerate_thenGenerateSpy() {\n        let variable = VarDeclarationType(isConstant: false, identifier: \"color\", type: type)\n        let argument = ArgumentType(label: \"a\", name: \"b\", type: type)\n        let function = FunctionDeclarationType(name: \"start\", arguments: [argument])\n        let protocolType = ProtocolType(name: \"Car\", variables: [variable], functions: [function])\n\n        equal(protocolType: protocolType, rows: [\n            \"class CarSpy: Car {\",\n            \"\",\n            \"var color: Color!\",\n            \"\",\n            \"var startCount = 0\",\n            \"var startB: Color?\",\n            \"\",\n            \"func start(a b: Color) {\",\n            \"startCount += 1\",\n            \"startB = b\",\n            \"}\",\n            \"\",\n            \"}\",\n            \"\",\n            \"\"\n            ]\n        )\n    }\n\n\n    private func equal(protocolType: ProtocolType, rows: [String]) {\n        let generatedRows = generator.generate(from: protocolType).components(separatedBy: \"\\n\")\n\n        XCTAssertEqual(generatedRows.count, rows.count)\n\n        _ = zip(generatedRows, rows).forEach({\n            XCTAssertEqual($0, $1)\n        })\n    }\n\n}\n\n\n//\n//  ParserTests.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 20/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nimport XCTest\n\nclass ParserTests: XCTestCase {\n\n    let parser = Parser()\n\n    func test_givenEmptyString_whenParse_thenEmptyResult() {\n        XCTAssert(parser.parse(\"\") == [Token]())\n    }\n\n    func test_givenWhiteCharacters_whenParse_thenEmptyResult() {\n        XCTAssert(parser.parse(\" \\t\\n \") == [Token]())\n    }\n\n    func test_givenIdentifier_whenParse_thenIdentifierToken() {\n        let result = parser.parse(\"a\")\n        XCTAssertEqual(result, [.identifier(name: \"a\")])\n    }\n\n    func test_givenProtocol_whenParse_thenProtocolToken() {\n        let result = parser.parse(\"protocol\")\n        XCTAssertEqual(result, [.protocol])\n    }\n\n    func test_givenProtocolWithSpce_whenParse_thenProtocolToken() {\n        let result = parser.parse(\"protocol \\t\")\n        XCTAssertEqual(result, [.protocol])\n    }\n\n    func test_givenProtocolTwice_whenParse_thenProtocolToken() {\n        let result = parser.parse(\"protocol protocol\")\n        XCTAssertEqual(result, [.protocol, .protocol])\n    }\n\n    func test_givenProtocolWithWhiteCharacters_whenParse_thenProtocolToken() {\n        let result = parser.parse(\" \\tprotocol\\t \")\n        XCTAssertEqual(result, [.protocol])\n    }\n\n    func test_givenColon_whenParse_thenColonToken() {\n        let result = parser.parse(\"protocol:\")\n        XCTAssertEqual(result, [.protocol, .colon])\n    }\n\n    func test_givenEqual_whenParse_thenEqualToken() {\n        let result = parser.parse(\"protocol = \")\n        XCTAssertEqual(result, [.protocol, .equal])\n    }\n\n    func test_givenLeftCurlyBracket_whenParse_thenleftCurlyBracketToken() {\n        let result = parser.parse(\":{\")\n        XCTAssertEqual(result, [.colon, .leftCurlyBracket])\n    }\n\n    func test_givenRightCurlyBracket_whenParse_thenRightCurlyBracketToken() {\n        let result = parser.parse(\":}\")\n        XCTAssertEqual(result, [.colon, .rightCurlyBracket])\n    }\n\n    func test_givenRightBracket_whenParse_thenRightBracketToken() {\n        let result = parser.parse(\":)\")\n        XCTAssertEqual(result, [.colon, .rightBracket])\n    }\n\n    func test_givenLeftBracket_whenParse_thenLeftBracketToken() {\n        let result = parser.parse(\":(\")\n        XCTAssertEqual(result, [.colon, .leftBracket])\n    }\n\n    func test_givenQuestionMark_whenParse_thenQuestionMarkToken() {\n        let result = parser.parse(\":?\")\n        XCTAssertEqual(result, [.colon, .questionMark])\n    }\n\n    func test_givenComma_whenParse_thenCommaToken() {\n        let result = parser.parse(\":,\")\n        XCTAssertEqual(result, [.colon, .comma])\n    }\n\n    func test_givenProtocolWithName_whenParse_thenProtocolAndNameToken() {\n        let result = parser.parse(\"protocol test\")\n        XCTAssertEqual(result, [.protocol, .identifier(name: \"test\")])\n    }\n\n    func test_givenVarWithName_whenParse_thenVariableToken() {\n        let result = parser.parse(\"var test\")\n        XCTAssertEqual(result, [.variable, .identifier(name: \"test\")])\n    }\n\n    func test_givenLetWithName_whenParse_thenConstantToken() {\n        let result = parser.parse(\"let test\")\n        XCTAssertEqual(result, [.constant, .identifier(name: \"test\")])\n    }\n\n    func test_givenGetWithName_whenParse_thenGetToken() {\n        let result = parser.parse(\"let get\")\n        XCTAssertEqual(result, [.constant, .get])\n    }\n\n    func test_givenSetWithName_whenParse_thenSetToken() {\n        let result = parser.parse(\"let set\")\n        XCTAssertEqual(result, [.constant, .set])\n    }\n\n    func test_givenFuncWithName_whenParse_thenFuncToken() {\n        let result = parser.parse(\"let func\")\n        XCTAssertEqual(result, [.constant, .function])\n    }\n\n    func test_givenArrowWithName_whenParse_thenArrowToken() {\n        let result = parser.parse(\"let->:\")\n        XCTAssertEqual(result, [.constant, .arrow, .colon])\n    }\n\n    func test_givenKeyWordIdentifier_whenParse_thenIdentifierToken() {\n        let result = parser.parse(\"let `protocol`:\")\n        XCTAssertEqual(result, [.constant, .identifier(name: \"protocol\"), .colon])\n    }\n\n    func test_givenProtocolDefinition_whenParse_thenProtocolTokens() {\n        var string = \"\"\n        string += \"protocol Satelite {\\n\"\n        string += \"    var panels: Int { get set }\\n\"\n        string += \"    func move(to x: Float, y: Float)\\n\"\n        string += \"}\"\n\n        let result = parser.parse(string)\n        let expected: [Token] = [\n            .protocol,\n            .identifier(name: \"Satelite\"),\n            .leftCurlyBracket,\n            .variable,\n            .identifier(name: \"panels\"),\n            .colon,\n            .identifier(name: \"Int\"),\n            .leftCurlyBracket,\n            .get,\n            .set,\n            .rightCurlyBracket,\n            .function,\n            .identifier(name: \"move\"),\n            .leftBracket,\n            .identifier(name: \"to\"),\n            .identifier(name: \"x\"),\n            .colon,\n            .identifier(name: \"Float\"),\n            .comma,\n            .identifier(name: \"y\"),\n            .colon,\n            .identifier(name: \"Float\"),\n            .rightBracket,\n            .rightCurlyBracket,\n        ]\n        XCTAssertEqual(result, expected)\n    }\n\n    func test_givenBigFile_whenParse_thenMeasureSpeed() {\n        \n    }\n}\n\n\n//\n//  ArgumentParserTests.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 27/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nimport XCTest\n\nclass ArgumentParserTests: XCTestCase {\n\n    let parser = ArgumentParser()\n\n    func test_givenInvalidToken_whenParse_thenThrowException() {\n        let storage = try Storage(tokens: [.colon])\n        testParserException(with: storage, .invalidName)\n    }\n\n    func test_givenInvalidColonToken_whenParse_thenThrowException() {\n        let storage = try Storage(tokens: [.identifier(name: \"name\"), .leftBracket])\n        testParserException(with: storage, .invalidColon)\n    }\n\n    func test_givenInvalidTypeToken_whenParse_thenThrowException() {\n        let storage = try Storage(tokens: [.identifier(name: \"name\"), .colon, .leftBracket])\n        testParserException(with: storage, .invalidType)\n    }\n\n    func test_givenArgument_whenParse_thenParse() {\n        let storage = try Storage(tokens: [.identifier(name: \"name\"), .colon, .identifier(name: \"Int\"), .colon])\n        do {\n            let argumenType = try parser.parse(storage: storage)\n            XCTAssertEqual(argumenType.label, nil)\n            XCTAssertEqual(argumenType.name, \"name\")\n            XCTAssertEqual(argumenType.type.name, \"Int\")\n            XCTAssertEqual(storage.current, .colon)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenArgumentWithLabel_whenParse_thenParse() {\n        let storage = try Storage(tokens: [.identifier(name: \"label\"), .identifier(name: \"name\"), .colon, .identifier(name: \"Int\"), .colon])\n        do {\n            let argumenType = try parser.parse(storage: storage)\n            XCTAssertEqual(argumenType.label, \"label\")\n            XCTAssertEqual(argumenType.name, \"name\")\n            XCTAssertEqual(argumenType.type.name, \"Int\")\n            XCTAssertEqual(storage.current, .colon)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    private func testParserException(with storage: Storage, _ exception: ArgumentParserError) {\n        testException(with: exception, parse: {\n            _ = try parser.parse(storage: storage)\n        })\n    }\n\n}\n\n\n//\n//  FunctionDeclarationParserTests.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 26/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nimport XCTest\n\nclass FunctionDeclarationParserTests: XCTestCase {\n\n    private let parser = FunctionDeclarationParser()\n    private let argumentTokens: [Token] = [.identifier(name: \"a\"), .colon, .identifier(name: \"Int\")]\n\n    func test_givenColon_whenParse_thenThrowException() {\n        let storage = try Storage(tokens: [.colon])\n        testParserException(with: storage, .invalidFunctionToken)\n    }\n\n    func test_givenInvalidNameToken_whenParse_thenThrowInvalidNameException() {\n        let storage = try Storage(tokens: [.function, .colon])\n        testParserException(with: storage, .invalidNameToken)\n    }\n\n    func test_givenInvalidLeftBracketNameToken_whenParse_thenThrowInvalidNameException() {\n        let storage = try Storage(tokens: [.function, .identifier(name: \"f\"), .colon])\n        testParserException(with: storage, .invalidLeftBracketToken)\n    }\n\n    func test_givenInvalidFunctionArgument_whenParse_thenThrowInvalidFunctionArgumentException() {\n        let storage = try Storage(tokens: [.function, .identifier(name: \"f\"), .leftBracket, .colon])\n        testParserException(with: storage, .invalidFunctionArgument)\n        XCTAssertEqual(storage.current, .function)\n    }\n\n    func test_givenFunction_whenParse_thenParse() {\n        let storage = try Storage(tokens: [.function, .identifier(name: \"f\"), .leftBracket, .rightBracket, .colon])\n        do {\n            let definition = try parser.parse(storage: storage)\n            XCTAssertEqual(definition.name, \"f\")\n            XCTAssertEqual(storage.current, .colon)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenFunctionWithArgument_whenParse_thenParse() {\n        var tokens: [Token] = [.function, .identifier(name: \"f\"), .leftBracket]\n        tokens += argumentTokens\n        tokens += [.rightBracket, .colon]\n        let storage = try Storage(tokens: tokens)\n        do {\n            let definition = try parser.parse(storage: storage)\n            XCTAssertEqual(definition.name, \"f\")\n            XCTAssertEqual(definition.arguments.count, 1)\n            XCTAssertEqual(definition.arguments[0].label, nil)\n            XCTAssertEqual(definition.arguments[0].name, \"a\")\n            XCTAssertEqual(definition.arguments[0].type.name, \"Int\")\n            XCTAssertEqual(storage.current, .colon)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenFunctionWithTwoArgument_whenParse_thenParse() {\n        var tokens: [Token] = [.function, .identifier(name: \"f\"), .leftBracket]\n        tokens += argumentTokens\n        tokens += [.comma]\n        tokens += argumentTokens\n        tokens += [.rightBracket, .colon]\n        let storage = try Storage(tokens: tokens)\n\n        do {\n            let definition = try parser.parse(storage: storage)\n            XCTAssertEqual(definition.name, \"f\")\n            XCTAssertEqual(definition.arguments.count, 2)\n            XCTAssertEqual(definition.arguments[1].label, nil)\n            XCTAssertEqual(definition.arguments[1].name, \"a\")\n            XCTAssertEqual(definition.arguments[1].type.name, \"Int\")\n            XCTAssertEqual(storage.current, .colon)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenFunctionWithThreeArgument_whenParse_thenParse() {\n        var tokens: [Token] = [.function, .identifier(name: \"f\"), .leftBracket]\n        tokens += argumentTokens\n        tokens += [.comma]\n        tokens += argumentTokens\n        tokens += [.comma]\n        tokens += argumentTokens\n        tokens += [.rightBracket, .colon]\n        let storage = try Storage(tokens: tokens)\n\n        do {\n            let definition = try parser.parse(storage: storage)\n            XCTAssertEqual(definition.name, \"f\")\n            XCTAssertEqual(definition.arguments.count, 3)\n            XCTAssertEqual(storage.current, .colon)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    private func testParserException(with storage: Storage, _ exception: FunctionDeclarationParserError) {\n        testException(with: exception, parse: {\n            _ = try parser.parse(storage: storage)\n        })\n    }\n}\n\n\n//\n//  HelpControllerTests.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 06/05/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nimport XCTest\n\nclass HelpControllerTests: XCTestCase {\n\n    func test_whenRun_thenSendHelpAtOutput() {\n        let outputSpy = ErrorGeneratorOutputSpy()\n        let helpController = HelpControllerImpl(output: outputSpy)\n        helpController.run()\n        XCTAssertEqual(outputSpy.showErrorCount, 1)\n        XCTAssertEqual(outputSpy.showErrorText, \"Required arguments:\\n--mocks path\\n\")\n    }\n}\n\nprivate class ErrorGeneratorOutputSpy: ErrorGeneratorOutput {\n\n    var showErrorText: String = \"\"\n    var showErrorCount = 0\n\n    func showError(text: String) {\n        showErrorCount += 1\n        showErrorText = text\n    }\n\n}\n\n\n//\n//  ProtocolParserTests.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 26/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nimport XCTest\n\nclass ProtocolParserTests: XCTestCase {\n\n    let parser = ProtocolParser()\n    private let varTokens: [Token] = [.variable, .identifier(name: \"a\"), .colon, .identifier(name: \"Int\"), .leftCurlyBracket, .get, .rightCurlyBracket]\n    private let funcTokens: [Token] = [.function, .identifier(name: \"a\"), .leftBracket, .rightBracket]\n\n    func test_givenInvalidToken_whenParse_thenThrowException() {\n        let storage = try Storage(tokens: [.colon])\n        testParserException(with: storage, .invalidProtocolToken)\n    }\n\n    func test_givenInvalidNameToken_whenParse_thenThrowException() {\n        let storage = try Storage(tokens: [.protocol, .colon])\n        testParserException(with: storage, .invalidNameToken)\n    }\n\n    func test_givenInvalidLeftBracketToken_whenParse_thenThrowException() {\n        let storage = try Storage(tokens: [.protocol, .identifier(name: \"p\"), .colon])\n        testParserException(with: storage, .expectedLeftBracket)\n    }\n\n    func test_givenInvalidRightBracketToken_whenParse_thenThrowException() {\n        let storage = try Storage(tokens: [.protocol, .identifier(name: \"p\"), .leftCurlyBracket, .colon])\n        testParserException(with: storage, .expectedRightBracket)\n    }\n\n    func test_givenEmptyProtocol_whenParse_thenParse() {\n        let storage = try Storage(tokens: [.protocol, .identifier(name: \"p\"), .leftCurlyBracket, .rightCurlyBracket])\n        do {\n            let `protocol` = try parser.parse(storage: storage)\n            XCTAssertEqual(`protocol`.name, \"p\")\n            XCTAssertEqual(storage.current, .rightCurlyBracket)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenEmptyProtocolInText_whenParse_thenParse() {\n        let storage = try Storage(tokens: [.protocol, .identifier(name: \"p\"), .leftCurlyBracket, .rightCurlyBracket, .colon])\n        do {\n            let `protocol` = try parser.parse(storage: storage)\n            XCTAssertEqual(`protocol`.name, \"p\")\n            XCTAssertEqual(storage.current, .colon)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenProtocolWithVariable_whenParse_thenParse() {\n        var tokens: [Token] = [.protocol, .identifier(name: \"p\"), .leftCurlyBracket]\n\n        tokens += varTokens\n        tokens += [.rightCurlyBracket, .colon]\n        let storage = try Storage(tokens: tokens)\n        do {\n            let `protocol` = try parser.parse(storage: storage)\n            XCTAssertEqual(`protocol`.name, \"p\")\n            XCTAssertEqual(`protocol`.variables.count, 1)\n            XCTAssertEqual(`protocol`.variables[0].identifier, \"a\")\n            XCTAssertEqual(`protocol`.variables[0].type.name, \"Int\")\n            XCTAssertEqual(storage.current, .colon)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenProtocolWithTwoVariables_whenParse_thenParse() {\n        var tokens: [Token] = [.protocol, .identifier(name: \"p\"), .leftCurlyBracket]\n\n        tokens += varTokens\n        tokens += varTokens\n        tokens += [.rightCurlyBracket, .colon]\n\n        let storage = try Storage(tokens: tokens)\n        do {\n            let `protocol` = try parser.parse(storage: storage)\n            XCTAssertEqual(`protocol`.name, \"p\")\n            XCTAssertEqual(`protocol`.variables.count, 2)\n            XCTAssertEqual(`protocol`.variables[1].identifier, \"a\")\n            XCTAssertEqual(`protocol`.variables[1].type.name, \"Int\")\n            XCTAssertEqual(storage.current, .colon)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenProtocolWithFunction_whenParse_thenParse() {\n        var tokens: [Token] = [.protocol, .identifier(name: \"p\"), .leftCurlyBracket]\n\n        tokens += funcTokens\n        tokens += [.rightCurlyBracket, .colon]\n\n        let storage = try Storage(tokens: tokens)\n        do {\n            let `protocol` = try parser.parse(storage: storage)\n            XCTAssertEqual(`protocol`.name, \"p\")\n            XCTAssertEqual(`protocol`.functions.count, 1)\n            XCTAssertEqual(`protocol`.functions[0].name, \"a\")\n            XCTAssertEqual(storage.current, .colon)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenProtocolWithTwoFunctions_whenParse_thenParse() {\n        var tokens: [Token] = [.protocol, .identifier(name: \"p\"), .leftCurlyBracket]\n\n        tokens += funcTokens\n        tokens += funcTokens\n        tokens += [.rightCurlyBracket, .colon]\n\n        let storage = try Storage(tokens: tokens)\n        do {\n            let `protocol` = try parser.parse(storage: storage)\n            XCTAssertEqual(`protocol`.name, \"p\")\n            XCTAssertEqual(`protocol`.functions.count, 2)\n            XCTAssertEqual(`protocol`.functions[1].name, \"a\")\n            XCTAssertEqual(storage.current, .colon)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenProtocolWithFunctionsAndVariables_whenParse_thenParse() {\n        var tokens: [Token] = [.protocol, .identifier(name: \"p\"), .leftCurlyBracket]\n\n        tokens += funcTokens\n        tokens += varTokens\n        tokens += funcTokens\n        tokens += varTokens\n        tokens += varTokens\n        tokens += funcTokens\n        tokens += [.rightCurlyBracket, .colon]\n\n        let storage = try Storage(tokens: tokens)\n        do {\n            let `protocol` = try parser.parse(storage: storage)\n            XCTAssertEqual(`protocol`.name, \"p\")\n            XCTAssertEqual(`protocol`.variables.count, 3)\n            XCTAssertEqual(`protocol`.functions.count, 3)\n            XCTAssertEqual(storage.current, .colon)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    private func testParserException(with storage: Storage, _ exception: ProtocolParserError) {\n        testException(with: exception, parse: {\n            _ = try parser.parse(storage: storage)\n        })\n    }\n}\n\n\n//\n//  StorageTests.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 26/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nimport XCTest\n\nclass StorageTests: XCTestCase {\n\n    func test_givenNoToken_whenInit_thenThrowException() {\n        testStorageException(with: .noTokens) {\n            _ = try Storage(tokens: [])\n        }\n    }\n\n    func test_givenOneToken_whenInit_thenInit() {\n        do {\n            _ = try Storage(tokens: [.colon])\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_whenGetCurrentToken_thenReturnFirst() {\n        do {\n            let storage = try Storage(tokens: [.colon, .comma])\n            XCTAssertEqual(storage.current, .colon)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenOneToken_whenGetNextToken_thenThrowException() {\n        testStorageException(with: .noNextToken) {\n            let storage = try Storage(tokens: [.colon])\n            _ = try storage.next()\n        }\n    }\n\n    func test_givenTwoTokens_whenGetNextToken_thenReturnSecondToken() {\n        do {\n            let storage = try Storage(tokens: [.colon, .comma])\n            let token = try storage.next()\n            XCTAssertEqual(token, .comma)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_whenGetPreviousToken_thenThrowException() {\n        testStorageException(with: .noPreviousToken) {\n            let storage = try Storage(tokens: [.colon])\n            _ = try storage.previous()\n        }\n    }\n\n    func test_givenTwoTokens_whenGetNextAndPreviousToken_thenReturnFirstToken() {\n        do {\n            let storage = try Storage(tokens: [.colon, .comma])\n            let token = try storage.next()\n            XCTAssertEqual(token, .comma)\n            let firstToken = try storage.previous()\n            XCTAssertEqual(firstToken, .colon)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_whenGetCurrentIndex_thenReturnIndex() {\n        do {\n            let storage = try Storage(tokens: [.colon, .comma])\n            _ = try storage.next()\n            let index = storage.currentIndex()\n            XCTAssertEqual(index, 1)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenInvalidIndex_whenSetIndex_thenThrowException() {\n        testStorageException(with: .indexOutOfBounds) {\n            let storage = try Storage(tokens: [.colon, .comma])\n            try storage.setCurrentIndex(100)\n        }\n    }\n\n    func test_givenValidIndex_whenSetIndex_thenSetIndex() {\n        do {\n            let storage = try Storage(tokens: [.colon, .comma])\n            try storage.setCurrentIndex(1)\n            XCTAssertEqual(storage.current, .comma)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenTokens_whenNextOccurrenceOfTokenNotExists_thenThrowException() {\n        testStorageException(with: .noNextToken) {\n            let storage = try Storage(tokens: [.colon, .colon, .colon])\n            try storage.moveToNext(.protocol)\n        }\n    }\n\n    func test_givenTokens_whenMoveToNextOccurrenceOfToken_thenCurrentTokenIsChanged() {\n        do {\n            let storage = try Storage(tokens: [.colon, .protocol, .comma])\n            XCTAssertEqual(storage.current, .colon)\n            try storage.moveToNext(.protocol)\n            XCTAssertEqual(storage.current, .protocol)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    private func testStorageException(with exception: StorageError, parse: (() throws -> Void)) {\n        testException(with: exception, parse: parse)\n    }\n}\n\n\n//\n//  TypeParserTests.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 23/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nimport XCTest\n\nclass TypeParserTests: XCTestCase {\n\n    let parser = TypeParser()\n\n    func test_givenColonToken_whenParse_thenThrowException() {\n        let storage = try Storage(tokens: [.colon])\n\n        testException(with: TypeParserError.invalidName) {\n            _ = try parser.parse(storage: storage)\n        }\n    }\n\n    func test_givenNameToken_whenParse_thenParse() {\n        let storage = try Storage(tokens: [.identifier(name: \"x\")])\n\n        do {\n            let type = try parser.parse(storage: storage)\n            XCTAssertEqual(type.name, \"x\")\n            XCTAssertEqual(type.isOptional, false)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenNameColonTokens_whenParse_thenParse() {\n        let storage = try Storage(tokens: [.identifier(name: \"x\"), .colon])\n\n        do {\n            let type = try parser.parse(storage: storage)\n            XCTAssertEqual(type.name, \"x\")\n            XCTAssertEqual(type.isOptional, false)\n            XCTAssertEqual(storage.current, .colon)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenNameQuestionMarkTokens_whenParse_thenParse() {\n        let storage = try Storage(tokens: [.identifier(name: \"x\"), .questionMark, .colon])\n\n        do {\n            let type = try parser.parse(storage: storage)\n            XCTAssertEqual(type.name, \"x\")\n            XCTAssertEqual(type.isOptional, true)\n            XCTAssertEqual(storage.current, .colon)\n        } catch {\n            XCTFail()\n        }\n    }\n}\n\n\n//\n//  VarDeclarationTypeTests.swift\n//  Rubicon\n//\n//  Created by Kryštof Matěj on 22/04/2017.\n//  Copyright © 2017 Kryštof Matěj. All rights reserved.\n//\n\nimport XCTest\n\nclass VarDeclarationTypeParserTests: XCTestCase {\n\n    let parser = VarDeclarationTypeParser()\n\n    func test_givenVariableToken_whenParse_thenThrowError() {\n        let storage = try Storage(tokens: [.variable])\n        do {\n            let parser = VarDeclarationTypeParser()\n            _ = try parser.parse(storage: storage)\n        } catch {\n            return\n        }\n\n        XCTFail()\n    }\n\n    func test_givenMissingColonToken_whenParse_thenThrowError() {\n        let storage = try Storage(tokens: [.variable, .identifier(name: \"x\"), .identifier(name: \"Int\")])\n        do {\n            let parser = VarDeclarationTypeParser()\n            _ = try parser.parse(storage: storage)\n            XCTAssertEqual(storage.current, .variable)\n        } catch {\n            return\n        }\n\n        XCTFail()\n    }\n\n    func test_givenInvalidTokens1_whenParse_thenThrowError() {\n        let storage = try Storage(tokens: [.constant, .identifier(name: \"x\"), .colon, .identifier(name: \"Int\"), .leftCurlyBracket, .get, .rightCurlyBracket])\n        do {\n\n            _ = try parser.parse(storage: storage)\n        } catch {\n            return\n        }\n\n        XCTFail()\n    }\n\n    func test_givenInvalidTokens2_whenParse_thenThrowError() {\n        let storage = try Storage(tokens: [.variable, .identifier(name: \"Int\"), .variable, .identifier(name: \"Int\"), .leftCurlyBracket, .get, .rightCurlyBracket])\n        do {\n            let parser = VarDeclarationTypeParser()\n            _ = try parser.parse(storage: storage)\n        } catch {\n            return\n        }\n\n        XCTFail()\n    }\n\n    func test_givenInvalidTokens3_whenParse_thenThrowError() {\n        let storage = try Storage(tokens: [.variable, .identifier(name: \"Int\"), .colon, .identifier(name: \"Int\"), .variable, .get, .rightCurlyBracket])\n        do {\n            let parser = VarDeclarationTypeParser()\n            _ = try parser.parse(storage: storage)\n        } catch {\n            XCTAssertEqual(storage.current, .variable)\n            return\n        }\n\n        XCTFail()\n    }\n\n    func test_givenInvalidTokens4_whenParse_thenThrowError() {\n        let storage = try Storage(tokens: [.variable, .identifier(name: \"Int\"), .colon, .identifier(name: \"Int\"), .leftCurlyBracket, .get, .variable])\n        do {\n            let parser = VarDeclarationTypeParser()\n            _ = try parser.parse(storage: storage)\n        } catch {\n            return\n        }\n\n        XCTFail()\n    }\n\n    func test_givenConstantDefinition_whenParse_thenParseVariable() {\n        let storage = try Storage(tokens: [.variable, .identifier(name: \"x\"), .colon, .identifier(name: \"Int\"), .leftCurlyBracket, .get, .rightCurlyBracket])\n\n        do {\n            let parser = VarDeclarationTypeParser()\n            let type = try parser.parse(storage: storage)\n            XCTAssertEqual(type.isConstant, true)\n            XCTAssertEqual(type.identifier, \"x\")\n            XCTAssertEqual(type.type.name, \"Int\")\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenVariableDefinition_whenParse_thenParseVariable() {\n        let storage = try Storage(tokens: [.variable, .identifier(name: \"x\"), .colon, .identifier(name: \"Int\"), .leftCurlyBracket, .get, .set, .rightCurlyBracket])\n\n        do {\n            let parser = VarDeclarationTypeParser()\n            let type = try parser.parse(storage: storage)\n            XCTAssertEqual(type.isConstant, false)\n            XCTAssertEqual(type.identifier, \"x\")\n            XCTAssertEqual(type.type.name, \"Int\")\n            XCTAssertEqual(type.type.isOptional, false)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenVariableDefinition2_whenParse_thenParseVariable() {\n        let storage = try Storage(tokens: [.variable, .identifier(name: \"x\"), .colon, .identifier(name: \"Int\"), .leftCurlyBracket, .set, .get, .rightCurlyBracket])\n\n        do {\n            let parser = VarDeclarationTypeParser()\n            let type = try parser.parse(storage: storage)\n            XCTAssertEqual(type.isConstant, false)\n            XCTAssertEqual(type.identifier, \"x\")\n            XCTAssertEqual(type.type.name, \"Int\")\n            XCTAssertEqual(type.type.isOptional, false)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenVariableDefinitionWithoutGet_whenParse_thenParseVariable() {\n        let storage = try Storage(tokens: [.variable, .identifier(name: \"x\"), .colon, .identifier(name: \"Int\"), .leftCurlyBracket, .set, .rightCurlyBracket])\n\n        do {\n            let parser = VarDeclarationTypeParser()\n            _ = try parser.parse(storage: storage)\n        } catch {\n            return\n        }\n        XCTFail()\n    }\n\n    func test_givenOptionVariableDefinition_whenParse_thenParseVariable() {\n        let storage = try Storage(tokens: [.variable, .identifier(name: \"x\"), .colon, .identifier(name: \"Int\"), .questionMark, .leftCurlyBracket, .set, .get, .rightCurlyBracket])\n\n        do {\n            let parser = VarDeclarationTypeParser()\n            let type = try parser.parse(storage: storage)\n            XCTAssertEqual(type.isConstant, false)\n            XCTAssertEqual(type.identifier, \"x\")\n            XCTAssertEqual(type.type.name, \"Int\")\n            XCTAssertEqual(type.type.isOptional, true)\n        } catch {\n            XCTFail()\n        }\n    }\n\n    func test_givenAlotOfTokensDefinition_whenParse_thenParseVariable() {\n        let storage = try Storage(tokens: [.variable, .identifier(name: \"x\"), .colon, .identifier(name: \"Int\"), .questionMark, .leftCurlyBracket, .set, .get, .rightCurlyBracket, .leftCurlyBracket, .set, .get, .rightCurlyBracket])\n\n        do {\n            let parser = VarDeclarationTypeParser()\n            let type = try parser.parse(storage: storage)\n            XCTAssertEqual(type.isConstant, false)\n            XCTAssertEqual(type.identifier, \"x\")\n            XCTAssertEqual(type.type.name, \"Int\")\n            XCTAssertEqual(type.type.isOptional, true)\n            XCTAssertEqual(storage.current, .leftCurlyBracket)\n        } catch {\n            XCTFail()\n        }\n    }\n}\n"
